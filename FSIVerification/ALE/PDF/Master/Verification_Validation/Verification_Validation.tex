\chapter{Verification and validation. }
When we set out to solve real world problem with numerical computing, we start by defining the mathematics, we implement the equations numerically and solve on a computer. We then use this solutions to extract data that will answer the questions of the problem we set out so solve. A problem then immediately arises, is this solution correct? To answer this we need to answer another question, is the problem defined correct mathematically, and if so are these equations solved correct numerically? Without answering these questions, being confident that your solutions are correct is difficult. \cite{Selin2014} The goal of this section will hence be to verify and validate the different numerical schemes. \\
Verification is process of assessing numerical correctness and accuracy of a computed solution. Validation is assessing physical accuracy of the numerical model, a process which is done by comparing numerical simulation with experimental data. 


\section{Verification}
In verification we get evidence that the numerical model derived from mathematics is solved correctly by the computer. The strategy will be to identify, quantify and reduce errors cause by mapping a mathematical model to a computational model. This does not address wether or not the mathematical model is in alignment with the real world. In verifying the code, order of convergence tests will be the most rigorous. Will will here compare an analytical solutions to the computed numerical solution. To do this test we will use the method of manufactured solutions (MMS) \cite{Roache2002}. This method entails manufacturing an exact solution that is non trivial but analytic. This solution is passed through the equations giving a source term, usually named $f$. This source term is set to equalize the given equation, and then a solution is calculated. If the calculation is correct our calculated solution should equal the manufactured solution down to a give precision, computer are only precise to about $10^-16$. We can then increase for instance the number of cells in our computational domain, and see if the difference between the manufactured and computed solution (eg. error) gets smaller. The rate at which the error reduces can be checked with mathematical theory, we can than be more confident that our computation is correct. This will also be done in time, by reducing the time steps and looking at the error.




\section{Validation}
After the code has been verified to see that we are indeed computing in the right fashion. We have to see that it is the right equations that are being solved. This is achieved using known benchmark tests. These tests supply us with a problem setup, initial and boundary conditions, and lastly results that we can compare with. We can then determine the accuracy of the computational model, and see if these meet the requirement needed to solve the problem. \cite{Selin2014} \\
In the following we will look at tests for the fluid solvers both alone, testing laminar to turbulent flow, and with solid. We will test the solid solver, and lastly the entire coupled FSI problem. 
\subsection{Taylor-Green vortex}

\subsection{Fluid-Structure Interaction between an elastic object and laminar incompressible flow}


